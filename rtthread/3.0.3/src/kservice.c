#include "rtthread.h"

char *rt_strncpy (char *dst, const char *src, rt_ubase_t n)
{
    if (n != 0) {
        char       *d = dst;
        const char *s = src;
        
        do {
            if ((*d++ = *s++) == 0) {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
                    *d++ = 0;
                break;
            }
        }
        while (--n != 0);
    }
    return dst;
}

/**
 * 将 8 位整形数的取值范围 0~255 作为数组__lowest_bit_bitmap[]的索引，
 * 索引值第一个出现 1(从最低位开始)的位号作为该数组索引下的成员值
 */
const rt_uint8_t __lowest_bit_bitmap[] = {
    0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};

/**
 * 该函数用于从一个32位的数中寻找第一个被置1的位（从低位开始），
 * 然后返回该位的索引（即位号）
 *
 * \return 返回第一个置1位的索引号。如果全为0，则返回0。
 */
int __rt_ffs (int value)
{
    /* 如果值为0，则直接返回0 */
    if (value == 0) return 0;
    
    /* 
     * 检查bits[07:00]
     * 这里加1的原因是避免当第一个置1的位是位0时，返回的索引号与值都为0时返回的
     * 索引号重复
     */
    if (value & 0xFF)
        return __lowest_bit_bitmap[value & 0xFF] + 1;
    
    /* 检查bits[15:08] */
    if (value & 0xFF00)
        return __lowest_bit_bitmap[(value & 0xFF00) >> 8] + 9;
    
    /* 检查bits[23:16] */
    if (value & 0xFF0000)
        return __lowest_bit_bitmap[(value & 0xFF0000) >> 16] + 17;
    
    /* 检查bits[31:24] */
    if (value & 0xFF000000)
        return __lowest_bit_bitmap[(value & 0xFF000000) >> 24] + 25;
    
    return 0;
}

